///////////////////////////////////////////////////////////////////////////////
// kuka_module.cpp
#include "TcPch.h"
#pragma hdrstop

#include "kuka_module.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// Ckuka_module
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module Ckuka_module
BEGIN_INTERFACE_MAP(Ckuka_module)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_ITcPostCyclic, ITcPostCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(Ckuka_module)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(Ckuka_module)
IMPLEMENT_ITCADI(Ckuka_module)
IMPLEMENT_ITCWATCHSOURCE(Ckuka_module)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of Ckuka_module 
BEGIN_SETOBJPARA_MAP(Ckuka_module)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_kuka_moduleAxisVelocityLimit, m_AxisVelocityLimit)
	SETOBJPARA_VALUE(PID_kuka_moduleAxisMotorTorqueLimit, m_AxisMotorTorqueLimit)
	SETOBJPARA_VALUE(PID_kuka_moduleAxisMotorTorqueSaturation, m_AxisMotorTorqueSaturation)
	SETOBJPARA_VALUE(PID_kuka_moduleAxisSensorTorqueLimit, m_AxisSensorTorqueLimit)
	SETOBJPARA_VALUE(PID_kuka_moduleAxisPositionSoftReserve, m_AxisPositionSoftReserve)
	SETOBJPARA_VALUE(PID_kuka_moduleRobotHanging, m_RobotHanging)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	SETOBJPARA_ITFPTR(PID_kuka_moduleTask, m_spTask)
	SETOBJPARA_ITFPTR(PID_kuka_moduleControllerFastCyclic, m_spControllerFastCyclic)
	SETOBJPARA_ITFPTR(PID_kuka_moduleControllerFastPostCyclic, m_spControllerFastPostCyclic)
	SETOBJPARA_ITFPTR(PID_kuka_modulePostCyclicCaller, m_spPostCyclicCaller)
	SETOBJPARA_DATAPTR(PID_kuka_modulefast_control_motor_torque, m_spfast_control_motor_torque)
	SETOBJPARA_DATAPTR(PID_kuka_modulefast_control_motor_enable, m_spfast_control_motor_enable)
	SETOBJPARA_DATAPTR(PID_kuka_modulefast_sensor_motor_torque_feedback, m_spfast_sensor_motor_torque_feedback)
	SETOBJPARA_DATAPTR(PID_kuka_modulefast_sensor_torque, m_spfast_sensor_torque)
	SETOBJPARA_DATAPTR(PID_kuka_modulefast_sensor_position, m_spfast_sensor_position)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of Ckuka_module 
BEGIN_GETOBJPARA_MAP(Ckuka_module)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_kuka_moduleAxisVelocityLimit, m_AxisVelocityLimit)
	GETOBJPARA_VALUE(PID_kuka_moduleAxisMotorTorqueLimit, m_AxisMotorTorqueLimit)
	GETOBJPARA_VALUE(PID_kuka_moduleAxisMotorTorqueSaturation, m_AxisMotorTorqueSaturation)
	GETOBJPARA_VALUE(PID_kuka_moduleAxisSensorTorqueLimit, m_AxisSensorTorqueLimit)
	GETOBJPARA_VALUE(PID_kuka_moduleAxisPositionSoftReserve, m_AxisPositionSoftReserve)
	GETOBJPARA_VALUE(PID_kuka_moduleRobotHanging, m_RobotHanging)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	GETOBJPARA_ITFPTR(PID_kuka_moduleTask, m_spTask)
	GETOBJPARA_ITFPTR(PID_kuka_moduleControllerFastCyclic, m_spControllerFastCyclic)
	GETOBJPARA_ITFPTR(PID_kuka_moduleControllerFastPostCyclic, m_spControllerFastPostCyclic)
	GETOBJPARA_ITFPTR(PID_kuka_modulePostCyclicCaller, m_spPostCyclicCaller)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of Ckuka_module
BEGIN_OBJPARAWATCH_MAP(Ckuka_module)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of Ckuka_module
BEGIN_OBJDATAAREA_MAP(Ckuka_module)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_kuka_moduleInput, m_Input)
	OBJDATAAREA_VALUE(ADI_kuka_moduleRobot_Inputs, m_Robot_Inputs)
	OBJDATAAREA_VALUE(ADI_kuka_moduleOutput, m_Output)
	OBJDATAAREA_VALUE(ADI_kuka_moduleRobot_Sensors, m_Robot_Sensors)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
Ckuka_module::Ckuka_module()
  : m_Trace(m_TraceLevelMax, m_spSrv),
  counter(0), dc_last(0)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_AxisVelocityLimit = 0;
	m_AxisMotorTorqueLimit = 0;
	m_AxisMotorTorqueSaturation = 0;
	m_AxisSensorTorqueLimit = 0;
	m_AxisPositionSoftReserve = 0;
	m_RobotHanging = FALSE;
	memset(&m_Input, 0, sizeof(m_Input));
	memset(&m_Robot_Inputs, 0, sizeof(m_Robot_Inputs));
	memset(&m_Output, 0, sizeof(m_Output));
	memset(&m_Robot_Sensors, 0, sizeof(m_Robot_Sensors));
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
Ckuka_module::~Ckuka_module() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(Ckuka_module)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT Ckuka_module::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);

  double tmp;
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

  //Prepare the limits
  memset((void*)&limits, 0, sizeof(limits));
  //Motor Torque Limit
  //Allow more than 100%, whereas the saturation and the underlying implementation
  //only allows to apply 100% nominal torque.
  tmp=m_AxisMotorTorqueLimit;
  if(tmp>200.0) tmp=200.0;
  else if(tmp<0.0) tmp=0.0;
  limits.motor_torque_limit_fraction=tmp/100.0;
  //Motor Torque Saturation
  tmp=m_AxisMotorTorqueSaturation;
  if(tmp>100.0) tmp=100.0;
  else if(tmp<0.0) tmp=0.0;
  limits.motor_torque_saturation=tmp/100.0;
  //Sensor Torque Limit
  tmp=m_AxisSensorTorqueLimit;
  if(tmp>100.0) tmp=100.0;
  else if(tmp<0.0) tmp=0.0;
  limits.sensor_torque_limit_fraction=tmp/100.0;
  //Velocity Limit
  tmp=m_AxisVelocityLimit;
  if(tmp>100.0) tmp=100.0;
  else if(tmp<0.0) tmp=0.0;
  limits.velocity_limit_fraction=tmp/100.0;
  //Software Position Reserve
  tmp=m_AxisPositionSoftReserve;
  if(tmp<0.0) tmp=0.0;
  limits.position_reserve=tmp*PI/180.0;
  //Robot Hanging
  limits.robot_hanging=m_RobotHanging;
  //Connect the Beckhoff I/O buffers with the slaves.
  robot1_parameters.ksoe_slave_parameters[0].input_buffer=&m_Input.Input_PDS1;
  robot1_parameters.ksoe_slave_parameters[0].output_buffer=&m_Output.Output_PDS1;
  robot1_parameters.ksoe_slave_parameters[1].input_buffer=&m_Input.Input_PDS23_1;
  robot1_parameters.ksoe_slave_parameters[1].output_buffer=&m_Output.Output_PDS23_1;
  robot1_parameters.ksoe_slave_parameters[2].input_buffer=&m_Input.Input_PDS23_2;
  robot1_parameters.ksoe_slave_parameters[2].output_buffer=&m_Output.Output_PDS23_2;
  robot1_parameters.ksoe_slave_parameters[3].input_buffer=&m_Input.Input_PDS23_3;
  robot1_parameters.ksoe_slave_parameters[3].output_buffer=&m_Output.Output_PDS23_3;
  robot1_parameters.fsoe_slave_parameters.input_buffer=&m_Input.Input_MFT;
  robot1_parameters.fsoe_slave_parameters.output_buffer=&m_Output.Output_MFT;
  robot1_parameters.NSR_INDICATOR=&m_Output.NSR_INDICATOR;
  robot1_parameters.NSR_INPUT=&m_Input.NSR_INPUT;
  robot1=new Robot(&robot1_parameters, &limits, m_spSrv, &m_Trace);
  hr=(robot1==NULL?S_FALSE:S_OK);

  // cleanup on failure
  if(FAILED(hr)) {
    safe_delete(robot1);
  }

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT Ckuka_module::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

  if(m_spTask.HasOID()) {
    if(!SUCCEEDED_DBG(hr=m_spSrv->TcQuerySmartObjectInterface(m_spTask))) {
      m_spTask=NULL;
    }
  }
  //Request the interfaces of the fast controller.
  if(m_spControllerFastCyclic.HasOID()) {
    if(!SUCCEEDED_DBG(m_spSrv->TcQuerySmartObjectInterface(m_spControllerFastCyclic))) {
      m_spControllerFastCyclic=NULL;
    }
  }
  if(m_spControllerFastPostCyclic.HasOID()) {
    if(!SUCCEEDED_DBG(m_spSrv->TcQuerySmartObjectInterface(m_spControllerFastPostCyclic))) {
      m_spControllerFastPostCyclic=NULL;
    }
  }

  // Initialize data pointer
  hr=FAILED(hr)?hr:InitDataPointer();

	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before this method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller();
    DeinitDataPointer();
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT Ckuka_module::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	RemoveModuleFromCaller();
  DeinitDataPointer();
  if(m_spTask) {
    m_spTask.Release();
  }
  m_spTask=NULL;

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT Ckuka_module::SetObjStateSP()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

  safe_delete(robot1);

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT Ckuka_module::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
  HRESULT hr=S_OK;
  AxisSensor input[ROBOT_NUM_AXIS];
  MFTSensor input_mft;
  AxisControl output[ROBOT_NUM_AXIS];
  LONGLONG dc;
  DWORD dc_time_L;

  //Read sensor signals from robot
  memset(input, 0, ROBOT_NUM_AXIS*sizeof(AxisSensor));
  memset(&input_mft, 0, sizeof(MFTSensor));
  robot1->ReadSensor(input, &input_mft);
  //Provide them at the "Robot Sensors"-Outputs
  for(int i=0;i<ROBOT_NUM_AXIS;i++) {
    m_Robot_Sensors.sensor_position[i]=input[i].position_filtered;
    m_Robot_Sensors.sensor_velocity[i]=input[i].velocity_filtered;
    m_Robot_Sensors.sensor_torque[i]=input[i].torque_filtered;
    m_Robot_Sensors.sensor_torque_derivative[i]=input[i].torque_derivative_filtered;
  }
  m_Robot_Sensors.sensor_mft_enable_button_pressed=input_mft.enable_button_pressed;
  m_Robot_Sensors.sensor_mft_enable_button_panic=input_mft.enable_button_panic;
  m_Robot_Sensors.sensor_mft_application_button=input_mft.application_button_pressed;
  m_Robot_Sensors.RobotState=(int)robot1->getCollectiveState();
  m_Robot_Sensors.MotionEnabled=robot1->isMotionEnabled()?1.0:0.0;
  //Enable or Disable robot according to current inputs
  motion_enable_logic.enableOrDisableRobot(robot1, &input_mft, m_Robot_Inputs.MotionEnable!=0.0, m_Robot_Inputs.MotionDisable!=0.0);
  //Transfer the read data to the fast controller
  if(m_spfast_sensor_motor_torque_feedback!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_motor_torque_feedback)[i]=input[i].motor_torque_feedback;
    }
  }
  if(m_spfast_sensor_position!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_position)[i]=input[i].position;
    }
  }
  if(m_spfast_sensor_torque!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_torque)[i]=input[i].torque;
    }
  }
  //Call controller cyclic
  if(m_spControllerFastCyclic!=NULL) {
    m_spControllerFastCyclic->CycleUpdate(ipTask, ipCaller, context);
  }
  //Read outputs from fast controller and feed them to the robot
  if(m_spfast_control_motor_torque!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      output[i].motor_torque=(*m_spfast_control_motor_torque)[i];
    }
  }
  else {
    //If none are availible, set them to invalid values (NaN).
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      output[i].motor_torque=getnan_();
    }
  }
  //If fast_control_motor_enable is connected, enable only those motors, which
  //have fast_control_motor_enable==1.0; All else are disabled.
  //If fast_control_motor_enable is not connected, always enable all motors.
  if(m_spfast_control_motor_enable!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      output[i].motor_enable=((*m_spfast_control_motor_enable)[i]==1.0);
    }
  }
  else {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      output[i].motor_enable=true;
    }
  }
  //Write control outputs
  m_spTask->GetCurrentDcTime(&dc);
  dc_time_L=(DWORD)dc;
  robot1->WriteControl(input, output, dc_time_L);

  /*
  m_spTask->GetCurPentiumTime(&dc);
  DWORD delta=(DWORD)(dc-dc_last);
  if(delta>125*1000/10) {
    m_Trace.Log(tlAlways, "! %lu", delta);
  }
  else if(delta>100*1000/10) {
    m_Trace.Log(tlAlways, "+ %lu", delta);
  }
  dc_last=dc;
  */
  /*
  counter++;
  if(counter>=(1000000/125)) {
    counter=0;
    m_Trace.Log(tlAlways, "debug output");
  }
  */

	return hr;
}
///</AutoGeneratedContent>

///<AutoGeneratedContent id="ImplementationOf_ITcPostCyclic">
HRESULT Ckuka_module::PostCyclicUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
  HRESULT hr=S_OK;

  if(m_spControllerFastPostCyclic) {
    m_spControllerFastPostCyclic->PostCyclicUpdate(ipTask, ipCaller, context);
  }

  return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT Ckuka_module::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for cyclic caller task");
	}
  if(m_spPostCyclicCaller.HasOID()) {
    if(SUCCEEDED_DBG(hr=m_spSrv->TcQuerySmartObjectInterface(m_spPostCyclicCaller))) {
      if(FAILED(hr=m_spPostCyclicCaller->AddPostModule(m_spPostCyclicCaller, THIS_CAST(ITcPostCyclic)))) {
        m_spPostCyclicCaller=NULL;
      }
    }
  }
  else {
    hr=ADS_E_INVALIDOBJID;
    SUCCEEDED_DBGT(hr, "Invalid OID specified for postcyclic caller task");
  }

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID Ckuka_module::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);
	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;
  if(m_spPostCyclicCaller) {
    m_spPostCyclicCaller->RemovePostModule(m_spPostCyclicCaller);
  }
  m_spPostCyclicCaller=NULL;
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
HRESULT Ckuka_module::InitDataPointer() {
  m_Trace.Log(tlVerbose, FENTERA);

  HRESULT hr=S_OK;

  hr=FAILED(hr)?hr:(m_spfast_control_motor_torque.HasOID()?m_spfast_control_motor_torque.Init(m_spSrv):hr);
  hr=FAILED(hr)?hr:(m_spfast_control_motor_enable.HasOID()?m_spfast_control_motor_enable.Init(m_spSrv):hr);
  hr=FAILED(hr)?hr:(m_spfast_sensor_motor_torque_feedback.HasOID()?m_spfast_sensor_motor_torque_feedback.Init(m_spSrv):hr);
  hr=FAILED(hr)?hr:(m_spfast_sensor_torque.HasOID()?m_spfast_sensor_torque.Init(m_spSrv):hr);
  hr=FAILED(hr)?hr:(m_spfast_sensor_position.HasOID()?m_spfast_sensor_position.Init(m_spSrv):hr);
  
  if(m_spfast_sensor_motor_torque_feedback!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_motor_torque_feedback)[i]=0.0;
    }
  }
  if(m_spfast_sensor_position!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_position)[i]=0.0;
    }
  }
  if(m_spfast_sensor_torque!=NULL) {
    for(int i=0;i<ROBOT_NUM_AXIS;i++) {
      (*m_spfast_sensor_torque)[i]=0.0;
    }
  }

  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID Ckuka_module::DeinitDataPointer() {
  m_Trace.Log(tlVerbose, FENTERA);

  m_spfast_control_motor_torque=NULL;
  m_spfast_control_motor_enable=NULL;
  m_spfast_sensor_motor_torque_feedback=NULL;
  m_spfast_sensor_torque=NULL;
  m_spfast_sensor_position=NULL;

  m_Trace.Log(tlVerbose, FLEAVEA);
}
