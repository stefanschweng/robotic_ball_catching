///////////////////////////////////////////////////////////////////////////////
// motive_interface_module.cpp
#include "TcPch.h"
#pragma hdrstop

#include "motive_interface_module.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// Cmotive_interface_module
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module Cmotive_interface_module
BEGIN_INTERFACE_MAP(Cmotive_interface_module)
  INTERFACE_ENTRY_ITCOMOBJECT()
  INTERFACE_ENTRY(IID_ITcADI, ITcADI)
  INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_ITcIoUdpProtocolRecv, ITcIoUdpProtocolRecv)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(Cmotive_interface_module)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(Cmotive_interface_module)
IMPLEMENT_ITCADI(Cmotive_interface_module)
IMPLEMENT_ITCWATCHSOURCE(Cmotive_interface_module)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of Cmotive_interface_module 
BEGIN_SETOBJPARA_MAP(Cmotive_interface_module)
  SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_motive_interface_moduleMotiveAddress, m_MotiveAddress)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	SETOBJPARA_ITFPTR(PID_motive_interface_moduleUdpProt, m_spUdpProt)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of Cmotive_interface_module 
BEGIN_GETOBJPARA_MAP(Cmotive_interface_module)
  GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_motive_interface_moduleMotiveAddress, m_MotiveAddress)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	GETOBJPARA_ITFPTR(PID_motive_interface_moduleUdpProt, m_spUdpProt)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of Cmotive_interface_module
BEGIN_OBJPARAWATCH_MAP(Cmotive_interface_module)
  OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of Cmotive_interface_module
BEGIN_OBJDATAAREA_MAP(Cmotive_interface_module)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_motive_interface_moduleOutput, m_Output)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
Cmotive_interface_module::Cmotive_interface_module()
  : m_Trace(m_TraceLevelMax, m_spSrv)
  , connection_timer(MAXULONG), connected(false) {
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	memset(&m_MotiveAddress, 0, sizeof(m_MotiveAddress));
	memset(&m_Output, 0, sizeof(m_Output));
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
Cmotive_interface_module::~Cmotive_interface_module() {
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(Cmotive_interface_module)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT Cmotive_interface_module::SetObjStatePS(PTComInitDataHdr pInitData) {
  m_Trace.Log(tlVerbose, FENTERA);

  HRESULT hr=S_OK;
  IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT Cmotive_interface_module::SetObjStateSO() {
  m_Trace.Log(tlVerbose, FENTERA);
  HRESULT hr=S_OK;

  // TODO: Add any additional initialization
  if(SUCCEEDED(hr)&&m_spUdpProt.HasOID()) {
    m_Trace.Log(tlInfo, FLEAVEA "Register UdpProt");
    if(SUCCEEDED_DBG(hr=m_spSrv->TcQuerySmartObjectInterface(m_spUdpProt))) {
      m_Trace.Log(tlInfo, FLEAVEA "Server: UdpProt listen to Port: %d", MOTIVE_PORT_DATA);
      if(FAILED(hr=m_spUdpProt->RegisterReceiver(MOTIVE_PORT_DATA, THIS_CAST(ITcIoUdpProtocolRecv)))) {
        m_Trace.Log(tlError, FLEAVEA "Server: UdpProtRegisterReceiver failed on Port: %d", MOTIVE_PORT_DATA);
        m_spUdpProt=NULL;
      }
    }
  }


  // If following call is successful the CycleUpdate method will be called, 
  // possibly even before this method has been left.
  hr=FAILED(hr)?hr:AddModuleToCaller();

  // Cleanup if transition failed at some stage
  if(FAILED(hr)) {
    if(m_spUdpProt!=NULL)
      m_spUdpProt->UnregisterReceiver(MOTIVE_PORT_DATA);
    m_spUdpProt=NULL;
    RemoveModuleFromCaller();
  }
  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT Cmotive_interface_module::SetObjStateOS() {
  m_Trace.Log(tlVerbose, FENTERA);
  HRESULT hr=S_OK;

  if(m_spUdpProt!=NULL)
    m_spUdpProt->UnregisterReceiver(MOTIVE_PORT_DATA);
  m_spUdpProt=NULL;
  RemoveModuleFromCaller();

  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT Cmotive_interface_module::SetObjStateSP() {
  m_Trace.Log(tlVerbose, FENTERA);
  HRESULT hr=S_OK;

  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT Cmotive_interface_module::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
  HRESULT hr=S_OK;
  sPacket p;

  if(connection_timer>=(10*1000*1000/50)) {
    connection_timer=0;
    keepalive_timer=0;
    connected=false;
    memset(&p, 0, sizeof(sPacket));
    p.iMessage=NAT_CONNECT;
    p.nDataBytes=0;
    if(m_spUdpProt) {
      m_spUdpProt->SendData(*((ULONG*)m_MotiveAddress), MOTIVE_PORT_COMMAND, MOTIVE_PORT_COMMAND, 4+p.nDataBytes, (void*)&p);
    }
  }
  if(connected && keepalive_timer>=(1000*1000/10)) {
    keepalive_timer=0;
    memset(&p, 0, sizeof(sPacket));
    p.iMessage=NAT_KEEPALIVE;
    p.nDataBytes=0;
    if(m_spUdpProt) {
      m_spUdpProt->SendData(*((ULONG*)m_MotiveAddress), MOTIVE_PORT_COMMAND, MOTIVE_PORT_COMMAND, 4+p.nDataBytes, (void*)&p);
    }
  }
  if(m_spUdpProt) {
    m_spUdpProt->CheckReceived();
  }

  connection_timer++;
  keepalive_timer++;

  return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT Cmotive_interface_module::AddModuleToCaller() {
  m_Trace.Log(tlVerbose, FENTERA);
  HRESULT hr=S_OK;
  if(m_spCyclicCaller.HasOID()) {
    if(SUCCEEDED_DBG(hr=m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller))) {
      if(FAILED(hr=m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic)))) {
        m_spCyclicCaller=NULL;
      }
    }
  }
  else {
    hr=ADS_E_INVALIDOBJID;
    SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
  }
  m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID Cmotive_interface_module::RemoveModuleFromCaller() {
  m_Trace.Log(tlVerbose, FENTERA);
  if(m_spCyclicCaller) {
    m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
  }
  m_spCyclicCaller=NULL;
  m_Trace.Log(tlVerbose, FLEAVEA);
}


///<AutoGeneratedContent id="ImplementationOf_ITcIoUdpProtocolRecv">
HRESULT Cmotive_interface_module::ReceiveData(ULONG ipAddr, USHORT udpDestPort, USHORT udpSrcPort, ULONG nData, PVOID pData, ETYPE_VLAN_HEADER* pVlan)
{
  HRESULT hr=S_OK;
  sPacket *p=(sPacket*)pData;
  if(p->iMessage==NAT_SERVERINFO||p->iMessage==NAT_FRAMEOFDATA) {
    connected=true;
    connection_timer=0;
  }
  if(connected) {
    Unpack((char *)pData);
  }
  return hr;
}
///</AutoGeneratedContent>

void Cmotive_interface_module::Unpack(char* ptr) {
  int i;

  UINT16 MessageID=*((UINT16*)ptr);
  ptr+=2;

  UINT16 nBytes=*((UINT16*)ptr); // size of the packet
  ptr+=2;

  if(MessageID==NAT_FRAMEOFDATA)      // FRAME OF MOCAP DATA packet
  {
    m_Output.FrameNumber=*((INT32*)ptr);
    ptr+=4;

    // Next 4 Bytes is the number of data sets (markersets, rigidbodies, etc)
    INT32 nMarkerSets=*((INT32*)ptr);
    ptr+=4;

    // Skip over marker sets. This has to be done in a loop since each entry is
    // variable in size.
    for(i=0; i<nMarkerSets; i++) {
      // Markerset name
      ptr+=strlen((char*)ptr)+1;

      // marker data
      INT32 nMarkers=*((INT32*)ptr);
      ptr+=4;
      ptr+=nMarkers*3*sizeof(float);
    }

    // Skip over unlabeled markers
    INT32 nOtherMarkers=*((INT32*)ptr);
    ptr+=4;
    ptr+=nOtherMarkers*3*sizeof(float);
    
    // Loop through rigidbodies
    m_Output.RigidBodyCount=*((INT32*)ptr);
    ptr+=4;

    INT32 rB_Array_size=sizeof(m_Output.RigidBodyArray)/sizeof(RigidBody);
    sRigidBodyData* ptr_RigidBody=(sRigidBodyData*)ptr;

    for(i=0;i<rB_Array_size && i<m_Output.RigidBodyCount; i++) {
      m_Output.RigidBodyArray[i].ID=ptr_RigidBody[i].ID;
      m_Output.RigidBodyArray[i].x=ptr_RigidBody[i].x;
      m_Output.RigidBodyArray[i].y=ptr_RigidBody[i].y;
      m_Output.RigidBodyArray[i].z=ptr_RigidBody[i].z;
      m_Output.RigidBodyArray[i].qw=ptr_RigidBody[i].qw;
      m_Output.RigidBodyArray[i].qx=ptr_RigidBody[i].qx;
      m_Output.RigidBodyArray[i].qy=ptr_RigidBody[i].qy;
      m_Output.RigidBodyArray[i].qz=ptr_RigidBody[i].qz;
      m_Output.RigidBodyArray[i].MeanError=ptr_RigidBody[i].MeanError;
      //params:
      // 0x01 : rigid body was successfully tracked in this frame
      m_Output.RigidBodyArray[i].bTrackingValid=(ptr_RigidBody[i].params&0x01)?1.0:0.0;
    }
    if(i<rB_Array_size) {
      memset(&m_Output.RigidBodyArray[i], 0, (rB_Array_size-i)*sizeof(RigidBody));
    }
    ptr+=m_Output.RigidBodyCount*sizeof(sRigidBodyData);

    // Skeletons 
    INT32 nSkeletons=*((INT32*)ptr);
    ptr+=4;
    //Skip over skeletons
    for(i=0;i<nSkeletons;i++) {
      ptr+=4;
      INT32 nRigidBodies=*((INT32*)ptr);
      ptr+=4;
      ptr+=nRigidBodies*sizeof(sRigidBodyData);
    }

    int lM_Array_size=sizeof(m_Output.LabeledMarkerArray)/sizeof(Marker);
    int sM_Array_size=sizeof(m_Output.SingleMarkerArray)/sizeof(Marker);
    // labeled markers
    m_Output.LabeledMarkerCount=*((INT32*)ptr);
    ptr+=4;

    sMarker* ptr_labeledMarkers=(sMarker*)ptr;
    INT32 SingleMarkerCount=0;

    // Loop through labeled markers
    for(i=0; i<lM_Array_size && i<m_Output.LabeledMarkerCount; i++) {
      m_Output.LabeledMarkerArray[i].MarkerID=ptr_labeledMarkers[i].MarkerID;
      m_Output.LabeledMarkerArray[i].ModelID=ptr_labeledMarkers[i].ModelID;
      m_Output.LabeledMarkerArray[i].x=ptr_labeledMarkers[i].x;
      m_Output.LabeledMarkerArray[i].y=ptr_labeledMarkers[i].y;
      m_Output.LabeledMarkerArray[i].z=ptr_labeledMarkers[i].z;
      m_Output.LabeledMarkerArray[i].markerSize=ptr_labeledMarkers[i].size;
      //params:
      // 0x01 : rigid body was successfully tracked in this frame
      // 0x02 : position provided by point cloud solve
      // 0x04 : position provided by model solve
      m_Output.LabeledMarkerArray[i].bOccluded=(ptr_labeledMarkers[i].params&0x01)?1.0:0.0;
      m_Output.LabeledMarkerArray[i].bPCSolved=(ptr_labeledMarkers[i].params&0x02)?1.0:0.0;
      m_Output.LabeledMarkerArray[i].bModelSolved=(ptr_labeledMarkers[i].params&0x04)?1.0:0.0;
      m_Output.LabeledMarkerArray[i].residualError=ptr_labeledMarkers[i].residual;

      // markers assigned to no rigidbody ==>> singleMarkers
      if(m_Output.LabeledMarkerArray[i].ModelID==0&&SingleMarkerCount<sM_Array_size) {
        memcpy(&m_Output.SingleMarkerArray[SingleMarkerCount], &m_Output.LabeledMarkerArray[i], sizeof(Marker));

        //matrix
        m_Output.SingleMarkerMatrix[0][SingleMarkerCount]=m_Output.LabeledMarkerArray[i].x;
        m_Output.SingleMarkerMatrix[1][SingleMarkerCount]=m_Output.LabeledMarkerArray[i].y;
        m_Output.SingleMarkerMatrix[2][SingleMarkerCount]=m_Output.LabeledMarkerArray[i].z;

        SingleMarkerCount++;
      }
    }
    if(i<lM_Array_size) {
      memset(&m_Output.LabeledMarkerArray[i], 0, (lM_Array_size-i)*sizeof(Marker));
    }
    if(SingleMarkerCount<sM_Array_size) {
      memset(&m_Output.SingleMarkerArray[SingleMarkerCount], 0, (sM_Array_size-SingleMarkerCount)*sizeof(Marker));
    }
    for(i=SingleMarkerCount;i<sM_Array_size;i++) {
      m_Output.SingleMarkerMatrix[0][i]=0.0;
      m_Output.SingleMarkerMatrix[1][i]=0.0;
      m_Output.SingleMarkerMatrix[2][i]=0.0;
    }
    m_Output.SingleMarkerCount=SingleMarkerCount;
    ptr+=m_Output.LabeledMarkerCount*sizeof(sMarker);

    //Skip over Force plates
    INT32 nForcePlates=*((INT32*)ptr);
    ptr+=4;
    for(i=0;i<nForcePlates;i++) {
      ptr+=4;
      INT32 nChannels=*((INT32*)ptr);
      ptr+=4;
      ptr+=nChannels*sizeof(sAnalogChannelData);
      ptr+=2;
    }

    //Skip over Devices
    INT32 nDevices=*((INT32*)ptr);
    ptr+=4;
    for(i=0;i<nForcePlates;i++) {
      ptr+=4;
      INT32 nChannels=*((INT32*)ptr);
      ptr+=4;
      ptr+=nChannels*sizeof(sAnalogChannelData);
      ptr+=2;
    }

    //Skip over Tmecode, TimecodeSubframe
    ptr+=8;
    m_Output.Timestamp=*((double*)ptr);
    ptr+=8;
    m_Output.CameraMidExposureTimestamp=*((UINT64*)ptr);

    m_Output.DataClock=!m_Output.DataClock;
  }
}
